|Two sum|||
|:---|:---|:---|
|角度一 | [enum] 集合内部组合  | 排列组合 n*n |
|角度二 | [hash] 集合内部映射  (值域落在定义域上)| hash函数复杂度[求解值域]*容器Search算法复杂度(筛选值域)|
|角度三 | [hash] 性能一般高[enum] | 空间换时间 |
---------------------------------------------------------
| Add two numbers|||
|:---|:---|:---:|
|反转单链表|递归到链表尾部再回溯|1.退出条件 2.递归路径 3.做点事情| 
|注意1|输入数组长度不一||
|注意2|进位问题||
|方法|头插法+反转单链表 or 尾插法|
---------------------------------------------------------
|Longest-substring (no repeating)||
|:---|:---|
|时间复杂度|n^3|
|二维数组动态分配1|```vector<vector<type>> Arr(n, vector<type>(n));```|
|二维数组动态分配2|```int **Arr = new int*[n](); for(i=0; i<n; i++>) Arr[i]=new int[n]();```|
|问题| 通过查表可以降低低时间复杂度但是会带来内存不够用问题|
---------------------------------------------------------
|Median-of-two-sorted-array||
|:---|:---|
|考查|整数归并算法的合并操作|
|归并复杂度|nlog(n)|
---------------------------------------------------------
|Merge Sort||
|:---|:---|
|实现方式|迭代法 / 递归法|
|空间/时间复杂度| n&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;nlog(n)|
|迭代要点|1. 迭代步长.&nbsp;&nbsp;&nbsp; 2. 右边界与数据长度.&nbsp;&nbsp;&nbsp; 3. 比较主体迭代|
|递归要点|1. 递归结束条件.&nbsp;&nbsp;&nbsp; 2. 函数处理区间一致左闭右开.&nbsp;&nbsp;&nbsp; 3. 递归主体的同步|
|区别| 1. 迭代法层次比较.&nbsp;&nbsp;&nbsp; 2. 递归法深度比较|
---------------------------------------------------------
|ZigZag-Conversion||
|:---|:---|
|问题|将一字符串经过竖向锯齿变换再横行输出|
|思路|遍历字符串计算锯齿变换后的下标，最后根据坐标大小输出|
|变换公式|行宽*所在行数 + 周期*步进 + 锯齿渐进|
|Int-reverse-and-atoi||
|:---|:---|
|注意|char与assci码的转换|
|问题1|从右到左逐个输出整数的字数`x=x%10; x/=10`|
|问题2|整数边界的处理 INT_MAX&nbsp;/&nbsp;INT_MIN| 
